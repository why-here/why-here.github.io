陈硕 - 《Linux 多线程服务端编程》第三章读书笔记
### 进程与线程
- 进程又自己独立的地址空间（有效地隔离数据）
- 线程共享地址空间，可以高效地共享数据
- 多个进程能高效地共享代码段，但不能共享数据
- 如果多个进程大量共享内存，等于把多进程当多线程来写

### 单线程服务器模型
使用广泛的模型：non-blocking + IO multiplexing，即 Reactor 模式。
基本结构：事件循环（event loop）+ 事件驱动（event driven）+ 事件回调（回调函数必须是非阻塞的）
适用于 IO 密集的应用

### 多线程服务器常用模型
1. 每个请求创建一个线程，使用阻塞 IO
2. 使用线程池，同样使用阻塞 IO，比 1 性能好
3. 使用 non-blocking + IO multiplexing + thread pool（one loop per thread）
4. Leader/Follower 等
推荐使用 3. 好处是：1. 线程数目固定，不会频繁创建与销毁；2. 可以在线程间调配负载，如根据实时性和数据量等特征进行分配。
总结：用 one Reactor event loop per thread + threa pool.

### 多线程服务器的使用场景
处理并发连接的两种方式：
1. “线程”很廉价。一台机器可以创建远高于 CPU 数目的“线程”，则一个线程处理一个连接，使用阻塞 IO，如 Python gevent，Go goroutine。这里的“线程”由语言的运行库自行调度，而非操作系统。
2. 线程宝贵。只能创建与 CPU 数目相当的线程。如 C++。使用 IO multiplexing + non-blocking。

### 线程应属于一个进程还是分属多个进程
有四种模型：
1. 运行一个单线程的进程
2. 运行一个多线程的进程
3. 运行多个单线程的进程
4. 运行多个多线程的进程
其中 3. 又可以分为
3a：把 1 中的进程运行多份
3b：主线程 + worker 进程。如 httpd 需要绑定到一个 TCP port 的情况。

对比 2 和 3b。
对比进程/线程启动和销毁开销与任务的开销，进行选择。假设进程/线程开销分别为 800us/50us，任务开销分别为 20s/10ms/20us。则任务分别适合的模型是
- 20s：多进程；
- 10ms：多线程；
- 20us：线程池或在当前线程直接处理。

